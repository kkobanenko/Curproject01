"""
–ö–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–∫—Å–ø–æ—Ä—Ç–æ–º –¥–∞–Ω–Ω—ã—Ö
"""
import streamlit as st
import pandas as pd
import json
from typing import Dict, Any, List, Optional, Union
from datetime import datetime
import io
import base64
from io import BytesIO
import zipfile
import tempfile
import os


class ExportManager:
    """–ö–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–∫—Å–ø–æ—Ä—Ç–æ–º –¥–∞–Ω–Ω—ã—Ö"""
    
    def __init__(self):
        self.export_formats = {
            'csv': {'name': 'CSV', 'mime': 'text/csv', 'extension': '.csv', 'category': '–¢–∞–±–ª–∏—á–Ω—ã–µ'},
            'excel': {'name': 'Excel', 'mime': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'extension': '.xlsx', 'category': '–¢–∞–±–ª–∏—á–Ω—ã–µ'},
            'json': {'name': 'JSON', 'mime': 'application/json', 'extension': '.json', 'category': '–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ'},
            'xml': {'name': 'XML', 'mime': 'application/xml', 'extension': '.xml', 'category': '–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ'},
            'yaml': {'name': 'YAML', 'mime': 'text/yaml', 'extension': '.yaml', 'category': '–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ'},
            'txt': {'name': '–¢–µ–∫—Å—Ç', 'mime': 'text/plain', 'extension': '.txt', 'category': '–¢–µ–∫—Å—Ç–æ–≤—ã–µ'},
            'html': {'name': 'HTML', 'mime': 'text/html', 'extension': '.html', 'category': '–¢–µ–∫—Å—Ç–æ–≤—ã–µ'},
            'markdown': {'name': 'Markdown', 'mime': 'text/markdown', 'extension': '.md', 'category': '–¢–µ–∫—Å—Ç–æ–≤—ã–µ'},
            'pdf': {'name': 'PDF', 'mime': 'application/pdf', 'extension': '.pdf', 'category': '–î–æ–∫—É–º–µ–Ω—Ç—ã'},
            'zip': {'name': 'ZIP –∞—Ä—Ö–∏–≤', 'mime': 'application/zip', 'extension': '.zip', 'category': '–ê—Ä—Ö–∏–≤—ã'},
            'tar': {'name': 'TAR –∞—Ä—Ö–∏–≤', 'mime': 'application/x-tar', 'extension': '.tar', 'category': '–ê—Ä—Ö–∏–≤—ã'},
            'sql': {'name': 'SQL', 'mime': 'application/sql', 'extension': '.sql', 'category': '–°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ'}
        }
    
    def render(self, data: Any, data_type: str, title: str = "–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö"):
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        st.header(f"üíæ {title}")
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∞–Ω–Ω—ã—Ö
        self._render_data_info(data, data_type)
        
        # –í—ã–±–æ—Ä —Ñ–æ—Ä–º–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞
        export_format = self._render_format_selection()
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞
        export_options = self._render_export_options(export_format, data_type)
        
        # –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä
        if export_format != 'zip':
            self._render_preview(data, export_format, export_options)
        
        # –≠–∫—Å–ø–æ—Ä—Ç
        self._render_export_actions(data, export_format, export_options, title)
        
        # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏
        self._render_additional_options(data, data_type)
    
    def _render_data_info(self, data: Any, data_type: str):
        """–û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –¥–∞–Ω–Ω—ã—Ö"""
        with st.expander("üìã –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–∞–Ω–Ω—ã—Ö", expanded=False):
            col1, col2 = st.columns(2)
            
            with col1:
                st.write("**–¢–∏–ø –¥–∞–Ω–Ω—ã—Ö:**")
                st.write(f"‚Ä¢ –ö–∞—Ç–µ–≥–æ—Ä–∏—è: {data_type}")
                st.write(f"‚Ä¢ –†–∞–∑–º–µ—Ä: {self._get_data_size(data)}")
                st.write(f"‚Ä¢ –≠–ª–µ–º–µ–Ω—Ç–æ–≤: {self._count_elements(data)}")
            
            with col2:
                st.write("**–°—Ç—Ä—É–∫—Ç—É—Ä–∞:**")
                if isinstance(data, list):
                    st.write(f"‚Ä¢ –¢–∏–ø: –°–ø–∏—Å–æ–∫")
                    if data:
                        st.write(f"‚Ä¢ –ü–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç: {type(data[0]).__name__}")
                elif isinstance(data, dict):
                    st.write(f"‚Ä¢ –¢–∏–ø: –°–ª–æ–≤–∞—Ä—å")
                    st.write(f"‚Ä¢ –ö–ª—é—á–∏: {', '.join(list(data.keys())[:5])}")
                elif isinstance(data, pd.DataFrame):
                    st.write(f"‚Ä¢ –¢–∏–ø: DataFrame")
                    st.write(f"‚Ä¢ –†–∞–∑–º–µ—Ä: {data.shape[0]} √ó {data.shape[1]}")
                else:
                    st.write(f"‚Ä¢ –¢–∏–ø: {type(data).__name__}")
    
    def _get_data_size(self, data: Any) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
        try:
            if isinstance(data, str):
                return f"{len(data)} —Å–∏–º–≤–æ–ª–æ–≤"
            elif isinstance(data, (list, dict)):
                return f"{len(data)} —ç–ª–µ–º–µ–Ω—Ç–æ–≤"
            elif isinstance(data, pd.DataFrame):
                return f"{data.shape[0]} √ó {data.shape[1]}"
            else:
                return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
        except:
            return "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"
    
    def _count_elements(self, data: Any) -> int:
        """–ü–æ–¥—Å—á–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤"""
        try:
            if isinstance(data, (list, dict)):
                return len(data)
            elif isinstance(data, pd.DataFrame):
                return data.shape[0] * data.shape[1]
            elif isinstance(data, str):
                return len(data.split())
            else:
                return 1
        except:
            return 0
    
    def _render_format_selection(self) -> str:
        """–í—ã–±–æ—Ä —Ñ–æ—Ä–º–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        st.subheader("üìÅ –í—ã–±–æ—Ä —Ñ–æ—Ä–º–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞")
        
        # –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ —Ñ–æ—Ä–º–∞—Ç–æ–≤ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
        format_categories = {}
        for fmt_key, fmt_info in self.export_formats.items():
            category = fmt_info['category']
            if category not in format_categories:
                format_categories[category] = []
            format_categories[category].append(fmt_key)
        
        selected_format = None
        
        for category, formats in format_categories.items():
            st.write(f"**{category}:**")
            cols = st.columns(len(formats))
            
            for i, fmt in enumerate(formats):
                with cols[i]:
                    if st.button(
                        self.export_formats[fmt]['name'],
                        key=f"format_{fmt}",
                        use_container_width=True
                    ):
                        selected_format = fmt
        
        if selected_format:
            st.success(f"‚úÖ –í—ã–±—Ä–∞–Ω —Ñ–æ—Ä–º–∞—Ç: {self.export_formats[selected_format]['name']}")
            return selected_format
        
        # –ï—Å–ª–∏ —Ñ–æ—Ä–º–∞—Ç –Ω–µ –≤—ã–±—Ä–∞–Ω, –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        default_format = st.selectbox(
            "–ò–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–æ—Ä–º–∞—Ç:",
            list(self.export_formats.keys()),
            format_func=lambda x: self.export_formats[x]['name']
        )
        
        return default_format
    
    def _render_export_options(self, export_format: str, data_type: str) -> Dict[str, Any]:
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        st.subheader("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞")
        
        options = {}
        
        if export_format == 'csv':
            options.update(self._get_csv_options())
        elif export_format == 'excel':
            options.update(self._get_excel_options())
        elif export_format == 'json':
            options.update(self._get_json_options())
        elif export_format == 'txt':
            options.update(self._get_txt_options())
        elif export_format == 'html':
            options.update(self._get_html_options())
        elif export_format == 'xml':
            options.update(self._get_xml_options())
        elif export_format == 'zip':
            options.update(self._get_zip_options())
        elif export_format == 'yaml':
            options.update(self._get_yaml_options())
        elif export_format == 'markdown':
            options.update(self._get_markdown_options())
        elif export_format == 'tar':
            options.update(self._get_tar_options())
        elif export_format == 'sql':
            options.update(self._get_sql_options())
        
        # –û–±—â–∏–µ –æ–ø—Ü–∏–∏
        options.update(self._get_common_options())
        
        return options
    
    def _get_csv_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è CSV —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            delimiter = st.selectbox("–†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å", [',', ';', '\t', '|'], key="csv_delimiter")
            encoding = st.selectbox("–ö–æ–¥–∏—Ä–æ–≤–∫–∞", ['utf-8', 'cp1251', 'iso-8859-1'], key="csv_encoding")
        
        with col2:
            include_index = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –∏–Ω–¥–µ–∫—Å", value=False, key="csv_index")
            quote_char = st.selectbox("–°–∏–º–≤–æ–ª –∫–∞–≤—ã—á–µ–∫", ['"', "'"], key="csv_quote")
        
        return {
            'delimiter': delimiter,
            'encoding': encoding,
            'include_index': include_index,
            'quote_char': quote_char
        }
    
    def _get_excel_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è Excel —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            sheet_name = st.text_input("–ù–∞–∑–≤–∞–Ω–∏–µ –ª–∏—Å—Ç–∞", value="Sheet1", key="excel_sheet")
            include_index = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –∏–Ω–¥–µ–∫—Å", value=False, key="excel_index")
        
        with col2:
            engine = st.selectbox("–î–≤–∏–∂–æ–∫", ['openpyxl', 'xlsxwriter'], key="excel_engine", help="openpyxl —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –¥–ª—è –ª—É—á—à–µ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏")
            float_format = st.text_input("–§–æ—Ä–º–∞—Ç —á–∏—Å–µ–ª", value="%.2f", key="excel_float")
        
        return {
            'sheet_name': sheet_name,
            'include_index': include_index,
            'engine': engine,
            'float_format': float_format
        }
    
    def _get_json_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è JSON —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            orient = st.selectbox(
                "–û—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è",
                ['records', 'index', 'columns', 'values', 'split', 'table'],
                key="json_orient"
            )
            indent = st.slider("–û—Ç—Å—Ç—É–ø", 0, 8, 2, key="json_indent")
        
        with col2:
            ensure_ascii = st.checkbox("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å ASCII", value=False, key="json_ascii")
            date_format = st.selectbox("–§–æ—Ä–º–∞—Ç –¥–∞—Ç", ['iso', 'epoch'], key="json_date")
        
        return {
            'orient': orient,
            'indent': indent,
            'ensure_ascii': ensure_ascii,
            'date_format': date_format
        }
    
    def _get_txt_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è —Ç–µ–∫—Å—Ç–æ–≤–æ–≥–æ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            encoding = st.selectbox("–ö–æ–¥–∏—Ä–æ–≤–∫–∞", ['utf-8', 'cp1251', 'iso-8859-1'], key="txt_encoding")
            line_separator = st.selectbox("–†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å —Å—Ç—Ä–æ–∫", ['\n', '\r\n', '\r'], key="txt_linesep")
        
        with col2:
            include_metadata = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ", value=True, key="txt_metadata")
            format_type = st.selectbox("–§–æ—Ä–º–∞—Ç", ['–ü—Ä–æ—Å—Ç–æ–π', '–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π'], key="txt_format")
        
        return {
            'encoding': encoding,
            'line_separator': line_separator,
            'include_metadata': include_metadata,
            'format_type': format_type
        }
    
    def _get_html_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è HTML —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            include_styles = st.checkbox("–í–∫–ª—é—á–∏—Ç—å —Å—Ç–∏–ª–∏", value=True, key="html_styles")
            table_id = st.text_input("ID —Ç–∞–±–ª–∏—Ü—ã", value="export_table", key="html_table_id")
        
        with col2:
            css_class = st.text_input("CSS –∫–ª–∞—Å—Å", value="table table-striped", key="html_css_class")
            responsive = st.checkbox("–ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞", value=True, key="html_responsive")
        
        return {
            'include_styles': include_styles,
            'table_id': table_id,
            'css_class': css_class,
            'responsive': responsive
        }
    
    def _get_xml_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è XML —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            root_name = st.text_input("–ö–æ—Ä–Ω–µ–≤–æ–π —ç–ª–µ–º–µ–Ω—Ç", value="data", key="xml_root")
            item_name = st.text_input("–≠–ª–µ–º–µ–Ω—Ç –∑–∞–ø–∏—Å–∏", value="item", key="xml_item")
        
        with col2:
            pretty_print = st.checkbox("–ö—Ä–∞—Å–∏–≤–æ–µ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ", value=True, key="xml_pretty")
            encoding = st.selectbox("–ö–æ–¥–∏—Ä–æ–≤–∫–∞", ['utf-8', 'cp1251'], key="xml_encoding")
        
        return {
            'root_name': root_name,
            'item_name': item_name,
            'pretty_print': pretty_print,
            'encoding': encoding
        }
    
    def _get_zip_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è ZIP —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            compression = st.selectbox("–°—Ç–µ–ø–µ–Ω—å —Å–∂–∞—Ç–∏—è", ['–ù–µ—Ç', '–ë—ã—Å—Ç—Ä–æ–µ', '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ'], key="zip_compression")
            include_metadata = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ", value=True, key="zip_metadata")
        
        with col2:
            password = st.text_input("–ü–∞—Ä–æ–ª—å (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)", type="password", key="zip_password")
            comment = st.text_input("–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –∞—Ä—Ö–∏–≤—É", key="zip_comment")
        
        return {
            'compression': compression,
            'include_metadata': include_metadata,
            'password': password,
            'comment': comment
        }
    
    def _get_common_options(self) -> Dict[str, Any]:
        """–û–±—â–∏–µ –æ–ø—Ü–∏–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        st.write("**–û–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:**")
        
        col1, col2 = st.columns(2)
        
        with col1:
            filename = st.text_input(
                "–ò–º—è —Ñ–∞–π–ª–∞",
                value=f"export_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                key="common_filename"
            )
            include_timestamp = st.checkbox("–î–æ–±–∞–≤–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—É—é –º–µ—Ç–∫—É", value=True, key="common_timestamp")
        
        with col2:
            quality = st.selectbox("–ö–∞—á–µ—Å—Ç–≤–æ", ['–í—ã—Å–æ–∫–æ–µ', '–°—Ä–µ–¥–Ω–µ–µ', '–ù–∏–∑–∫–æ–µ'], key="common_quality")
            preview_size = st.slider("–†–∞–∑–º–µ—Ä –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞", 10, 100, 50, key="common_preview")
        
        return {
            'filename': filename,
            'include_timestamp': include_timestamp,
            'quality': quality,
            'preview_size': preview_size
        }
    
    def _render_preview(self, data: Any, export_format: str, options: Dict[str, Any]):
        """–ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        st.subheader("üëÅÔ∏è –ü—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–æ—Å–º–æ—Ç—Ä")
        
        try:
            preview_data = self._prepare_preview_data(data, export_format, options)
            
            if preview_data:
                if export_format in ['csv', 'txt']:
                    st.text_area(
                        "–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä",
                        value=preview_data,
                        height=200,
                        disabled=True,
                        key=f"preview_{export_format}"
                    )
                elif export_format == 'json':
                    st.json(preview_data)
                elif export_format == 'html':
                    st.components.v1.html(preview_data, height=300)
                elif export_format == 'xml':
                    st.code(preview_data, language='xml')
                else:
                    st.write("–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –¥–∞–Ω–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞")
            else:
                st.warning("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä")
                
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞: {str(e)}")
    
    def _prepare_preview_data(self, data: Any, export_format: str, options: Dict[str, Any]) -> Optional[str]:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞"""
        try:
            preview_size = options.get('preview_size', 50)
            
            if export_format == 'csv':
                if isinstance(data, pd.DataFrame):
                    return data.head(preview_size).to_csv(
                        sep=options.get('delimiter', ','),
                        index=options.get('include_index', False)
                    )
                elif isinstance(data, list):
                    df = pd.DataFrame(data[:preview_size])
                    return df.to_csv(
                        sep=options.get('delimiter', ','),
                        index=options.get('include_index', False)
                    )
            
            elif export_format == 'json':
                if isinstance(data, list):
                    return json.dumps(data[:preview_size], indent=options.get('indent', 2), ensure_ascii=options.get('ensure_ascii', False))
                elif isinstance(data, dict):
                    return json.dumps(data, indent=options.get('indent', 2), ensure_ascii=options.get('ensure_ascii', False))
            
            elif export_format == 'txt':
                if isinstance(data, list):
                    return '\n'.join([str(item) for item in data[:preview_size]])
                elif isinstance(data, str):
                    return data[:preview_size * 10]  # –ü—Ä–∏–º–µ—Ä–Ω–æ 10 —Å–∏–º–≤–æ–ª–æ–≤ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç
            
            elif export_format == 'html':
                if isinstance(data, pd.DataFrame):
                    return data.head(preview_size).to_html(
                        table_id=options.get('table_id', 'export_table'),
                        classes=options.get('css_class', 'table table-striped'),
                        index=options.get('include_index', False)
                    )
            
            elif export_format == 'xml':
                if isinstance(data, list):
                    root_name = options.get('root_name', 'data')
                    item_name = options.get('item_name', 'item')
                    xml_content = f'<{root_name}>\n'
                    for item in data[:preview_size]:
                        xml_content += f'  <{item_name}>{item}</{item_name}>\n'
                    xml_content += f'</{root_name}>'
                    return xml_content
            
            return None
            
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞: {str(e)}")
            return None
    
    def _render_export_actions(self, data: Any, export_format: str, options: Dict[str, Any], title: str):
        """–î–µ–π—Å—Ç–≤–∏—è –ø–æ —ç–∫—Å–ø–æ—Ä—Ç—É"""
        st.subheader("üì§ –≠–∫—Å–ø–æ—Ä—Ç")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üíæ –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å", key="export_button", use_container_width=True):
                self._perform_export(data, export_format, options, title)
        
        with col2:
            if st.button("üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å –≤ –±—É—Ñ–µ—Ä", key="copy_button", use_container_width=True):
                self._copy_to_clipboard(data, export_format, options)
        
        with col3:
            if st.button("üìß –û—Ç–ø—Ä–∞–≤–∏—Ç—å –ø–æ email", key="email_button", use_container_width=True):
                self._send_via_email(data, export_format, options, title)
    
    def _perform_export(self, data: Any, export_format: str, options: Dict[str, Any], title: str):
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        try:
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö
            export_data = self._prepare_export_data(data, export_format, options)
            
            if export_data is None:
                st.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞")
                return
            
            # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞
            filename = self._generate_filename(options, export_format)
            
            # –°–æ–∑–¥–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
            if export_format == 'zip':
                # –î–ª—è ZIP —Å–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                with tempfile.NamedTemporaryFile(delete=False, suffix='.zip') as tmp_file:
                    tmp_file.write(export_data)
                    tmp_file_path = tmp_file.name
                
                with open(tmp_file_path, 'rb') as f:
                    st.download_button(
                        label=f"üì• –°–∫–∞—á–∞—Ç—å {self.export_formats[export_format]['name']}",
                        data=f.read(),
                        file_name=filename,
                        mime=self.export_formats[export_format]['mime']
                    )
                
                # –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                os.unlink(tmp_file_path)
            else:
                st.download_button(
                    label=f"üì• –°–∫–∞—á–∞—Ç—å {self.export_formats[export_format]['name']}",
                    data=export_data,
                    file_name=filename,
                    mime=self.export_formats[export_format]['mime']
                )
            
            st.success(f"‚úÖ –≠–∫—Å–ø–æ—Ä—Ç –≤ —Ñ–æ—Ä–º–∞—Ç–µ {self.export_formats[export_format]['name']} –≥–æ—Ç–æ–≤")
            
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞: {str(e)}")
    
    def _prepare_export_data(self, data: Any, export_format: str, options: Dict[str, Any]) -> Optional[Union[str, bytes]]:
        """–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        try:
            if export_format == 'csv':
                if isinstance(data, pd.DataFrame):
                    return data.to_csv(
                        sep=options.get('delimiter', ','),
                        index=options.get('include_index', False),
                        encoding=options.get('encoding', 'utf-8')
                    )
                elif isinstance(data, list):
                    df = pd.DataFrame(data)
                    return df.to_csv(
                        sep=options.get('delimiter', ','),
                        index=options.get('include_index', False),
                        encoding=options.get('encoding', 'utf-8')
                    )
            
            elif export_format == 'excel':
                try:
                    if isinstance(data, pd.DataFrame):
                        buffer = BytesIO()
                        with pd.ExcelWriter(buffer, engine=options.get('engine', 'openpyxl')) as writer:
                            data.to_excel(
                                writer,
                                sheet_name=options.get('sheet_name', 'Sheet1'),
                                index=options.get('include_index', False),
                                float_format=options.get('float_format', '%.2f')
                            )
                        return buffer.getvalue()
                    elif isinstance(data, list):
                        df = pd.DataFrame(data)
                        buffer = BytesIO()
                        with pd.ExcelWriter(buffer, engine=options.get('engine', 'openpyxl')) as writer:
                            df.to_excel(
                                writer,
                                sheet_name=options.get('sheet_name', 'Sheet1'),
                                index=options.get('include_index', False)
                            )
                        return buffer.getvalue()
                except ImportError:
                    st.error("–î–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ Excel —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ openpyxl: `pip install openpyxl`")
                    return None
            
            elif export_format == 'json':
                if isinstance(data, list):
                    return json.dumps(
                        data,
                        indent=options.get('indent', 2),
                        ensure_ascii=options.get('ensure_ascii', False)
                    )
                elif isinstance(data, dict):
                    return json.dumps(
                        data,
                        indent=options.get('indent', 2),
                        ensure_ascii=options.get('ensure_ascii', False)
                    )
            
            elif export_format == 'txt':
                if isinstance(data, list):
                    lines = []
                    if options.get('include_metadata', True):
                        lines.append(f"–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                        lines.append(f"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤: {len(data)}")
                        lines.append("-" * 50)
                    
                    for item in data:
                        if options.get('format_type') == '–°—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π':
                            lines.append(json.dumps(item, ensure_ascii=False, indent=2))
                        else:
                            lines.append(str(item))
                    
                    return '\n'.join(lines)
                elif isinstance(data, str):
                    return data
            
            elif export_format == 'html':
                if isinstance(data, pd.DataFrame):
                    return data.to_html(
                        table_id=options.get('table_id', 'export_table'),
                        classes=options.get('css_class', 'table table-striped'),
                        index=options.get('include_index', False)
                    )
            
            elif export_format == 'xml':
                if isinstance(data, list):
                    root_name = options.get('root_name', 'data')
                    item_name = options.get('item_name', 'item')
                    xml_content = f'<?xml version="1.0" encoding="{options.get("encoding", "utf-8")}"?>\n'
                    xml_content += f'<{root_name}>\n'
                    for item in data:
                        xml_content += f'  <{item_name}>{item}</{item_name}>\n'
                    xml_content += f'</{root_name}>'
                    return xml_content
            
            elif export_format == 'zip':
                return self._create_zip_archive(data, options)
            
            elif export_format == 'yaml':
                return self._create_yaml_export(data, options)
            
            elif export_format == 'markdown':
                return self._create_markdown_export(data, options)
            
            elif export_format == 'tar':
                return self._create_tar_archive(data, options)
            
            elif export_format == 'sql':
                return self._create_sql_export(data, options)
            
            return None
            
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {str(e)}")
            return None
    
    def _create_zip_archive(self, data: Any, options: Dict[str, Any]) -> bytes:
        """–°–æ–∑–¥–∞–Ω–∏–µ ZIP –∞—Ä—Ö–∏–≤–∞"""
        buffer = BytesIO()
        
        with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            if isinstance(data, list):
                # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ä–º–∞—Ç–æ–≤
                formats_to_include = ['csv', 'json', 'txt']
                
                for fmt in formats_to_include:
                    try:
                        if fmt == 'csv':
                            df = pd.DataFrame(data)
                            csv_data = df.to_csv(index=False)
                            zip_file.writestr(f"data.{fmt}", csv_data)
                        elif fmt == 'json':
                            json_data = json.dumps(data, indent=2, ensure_ascii=False)
                            zip_file.writestr(f"data.{fmt}", json_data)
                        elif fmt == 'txt':
                            txt_data = '\n'.join([str(item) for item in data])
                            zip_file.writestr(f"data.{fmt}", txt_data)
                    except:
                        continue
            
            # –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            if options.get('include_metadata', True):
                metadata = {
                    'export_time': datetime.now().isoformat(),
                    'data_type': type(data).__name__,
                    'data_size': len(data) if isinstance(data, (list, dict)) else 1,
                    'export_options': options
                }
                
                metadata_json = json.dumps(metadata, indent=2, ensure_ascii=False)
                zip_file.writestr("metadata.json", metadata_json)
            
            # –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π
            if options.get('comment'):
                zip_file.comment = options['comment'].encode('utf-8')
        
        return buffer.getvalue()
    
    def _generate_filename(self, options: Dict[str, Any], export_format: str) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–º–µ–Ω–∏ —Ñ–∞–π–ª–∞"""
        base_name = options.get('filename', 'export')
        
        if options.get('include_timestamp', True):
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            base_name = f"{base_name}_{timestamp}"
        
        extension = self.export_formats[export_format]['extension']
        return f"{base_name}{extension}"
    
    def _copy_to_clipboard(self, data: Any, export_format: str, options: Dict[str, Any]):
        """–ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞"""
        try:
            export_data = self._prepare_export_data(data, export_format, options)
            
            if export_data:
                if isinstance(export_data, bytes):
                    export_data = export_data.decode('utf-8')
                
                # –í Streamlit –∏—Å–ø–æ–ª—å–∑—É–µ–º session_state –¥–ª—è –∏–º–∏—Ç–∞—Ü–∏–∏ –±—É—Ñ–µ—Ä–∞
                st.session_state['clipboard_data'] = export_data
                st.success("‚úÖ –î–∞–Ω–Ω—ã–µ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω—ã –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞")
                
                # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
                if st.button("üìã –ü–æ–∫–∞–∑–∞—Ç—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ"):
                    st.text_area("–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:", value=export_data, height=200)
            else:
                st.error("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–≥–æ—Ç–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è")
                
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è: {str(e)}")
    
    def _send_via_email(self, data: Any, export_format: str, options: Dict[str, Any], title: str):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ –ø–æ email"""
        st.info("üìß –§—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ email –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏")
        
        # –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –±—É–¥—É—â–µ–π —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
        with st.expander("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ email", expanded=False):
            st.text_input("Email –ø–æ–ª—É—á–∞—Ç–µ–ª—è", key="email_recipient")
            st.text_input("–¢–µ–º–∞ –ø–∏—Å—å–º–∞", value=f"–≠–∫—Å–ø–æ—Ä—Ç: {title}", key="email_subject")
            st.text_area("–¢–µ–∫—Å—Ç –ø–∏—Å—å–º–∞", key="email_body")
            st.button("–û—Ç–ø—Ä–∞–≤–∏—Ç—å", disabled=True)
    
    def _render_additional_options(self, data: Any, data_type: str):
        """–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏ —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        st.subheader("üîß –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –æ–ø—Ü–∏–∏")
        
        col1, col2 = st.columns(2)
        
        with col1:
            # –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —ç–∫—Å–ø–æ—Ä—Ç–∞
            schedule_export = st.checkbox("–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–≥—É–ª—è—Ä–Ω—ã–π —ç–∫—Å–ø–æ—Ä—Ç", key="schedule_export")
            if schedule_export:
                st.selectbox("–ß–∞—Å—Ç–æ—Ç–∞", ["–ï–∂–µ–¥–Ω–µ–≤–Ω–æ", "–ï–∂–µ–Ω–µ–¥–µ–ª—å–Ω–æ", "–ï–∂–µ–º–µ—Å—è—á–Ω–æ"], key="export_frequency")
                st.time_input("–í—Ä–µ–º—è —ç–∫—Å–ø–æ—Ä—Ç–∞", key="export_time")
        
        with col2:
            # –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            enable_notifications = st.checkbox("–í–∫–ª—é—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", key="enable_notifications")
            if enable_notifications:
                st.checkbox("Email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", key="email_notifications")
                st.checkbox("Push —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", key="push_notifications")
        
        # –ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è
        st.write("**–ê–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏—è:**")
        auto_export = st.checkbox("–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —ç–∫—Å–ø–æ—Ä—Ç –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö", key="auto_export")
        if auto_export:
            st.selectbox("–§–æ—Ä–º–∞—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é", list(self.export_formats.keys()), 
                        format_func=lambda x: self.export_formats[x]['name'])
            st.text_input("–ü–∞–ø–∫–∞ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è", key="export_folder")
    
    def _get_yaml_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è YAML —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            indent = st.slider("–û—Ç—Å—Ç—É–ø", 2, 8, 2, key="yaml_indent")
            default_flow_style = st.checkbox("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å flow style", value=False, key="yaml_flow")
        
        with col2:
            allow_unicode = st.checkbox("–†–∞–∑—Ä–µ—à–∏—Ç—å Unicode", value=True, key="yaml_unicode")
            sort_keys = st.checkbox("–°–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á–∏", value=False, key="yaml_sort")
        
        return {
            'indent': indent,
            'default_flow_style': default_flow_style,
            'allow_unicode': allow_unicode,
            'sort_keys': sort_keys
        }
    
    def _get_markdown_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è Markdown —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            include_metadata = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ", value=True, key="md_metadata")
            table_format = st.selectbox("–§–æ—Ä–º–∞—Ç —Ç–∞–±–ª–∏—Ü", ["GitHub", "Grid", "Simple"], key="md_table_format")
        
        with col2:
            include_toc = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –æ–≥–ª–∞–≤–ª–µ–Ω–∏–µ", value=False, key="md_toc")
            header_level = st.selectbox("–£—Ä–æ–≤–µ–Ω—å –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤", [1, 2, 3, 4, 5, 6], index=1, key="md_header_level")
        
        return {
            'include_metadata': include_metadata,
            'table_format': table_format,
            'include_toc': include_toc,
            'header_level': header_level
        }
    
    def _get_tar_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è TAR —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            compression = st.selectbox("–°–∂–∞—Ç–∏–µ", ["–ù–µ—Ç", "Gzip", "Bzip2"], key="tar_compression")
            include_metadata = st.checkbox("–í–∫–ª—é—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ", value=True, key="tar_metadata")
        
        with col2:
            comment = st.text_input("–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –∞—Ä—Ö–∏–≤—É", key="tar_comment")
            preserve_permissions = st.checkbox("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞", value=False, key="tar_permissions")
        
        return {
            'compression': compression,
            'include_metadata': include_metadata,
            'comment': comment,
            'preserve_permissions': preserve_permissions
        }
    
    def _get_sql_options(self) -> Dict[str, Any]:
        """–û–ø—Ü–∏–∏ –¥–ª—è SQL —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        col1, col2 = st.columns(2)
        
        with col1:
            table_name = st.text_input("–ò–º—è —Ç–∞–±–ª–∏—Ü—ã", value="exported_data", key="sql_table_name")
            include_create = st.checkbox("–í–∫–ª—é—á–∏—Ç—å CREATE TABLE", value=True, key="sql_create")
        
        with col2:
            include_drop = st.checkbox("–í–∫–ª—é—á–∏—Ç—å DROP TABLE", value=False, key="sql_drop")
            batch_size = st.number_input("–†–∞–∑–º–µ—Ä –ø–∞–∫–µ—Ç–∞", min_value=1, max_value=1000, value=100, key="sql_batch_size")
        
        return {
            'table_name': table_name,
            'include_create': include_create,
            'include_drop': include_drop,
            'batch_size': batch_size
        }
    
    def _create_yaml_export(self, data: Any, options: Dict[str, Any]) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ YAML —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        try:
            import yaml
            
            if isinstance(data, list):
                yaml_data = data
            elif isinstance(data, dict):
                yaml_data = data
            elif isinstance(data, pd.DataFrame):
                yaml_data = data.to_dict('records')
            else:
                yaml_data = {'data': data}
            
            return yaml.dump(
                yaml_data,
                default_flow_style=options.get('default_flow_style', False),
                allow_unicode=options.get('allow_unicode', True),
                sort_keys=options.get('sort_keys', False),
                indent=options.get('indent', 2)
            )
        except ImportError:
            st.error("–î–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞ –≤ YAML —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ PyYAML: `pip install PyYAML`")
            return None
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è YAML: {str(e)}")
            return None
    
    def _create_markdown_export(self, data: Any, options: Dict[str, Any]) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ Markdown —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        try:
            md_content = []
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            header_level = options.get('header_level', 2)
            md_content.append(f"{'#' * header_level} –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö")
            md_content.append("")
            
            # –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
            if options.get('include_metadata', True):
                md_content.append("## –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ")
                md_content.append(f"- **–î–∞—Ç–∞ —ç–∫—Å–ø–æ—Ä—Ç–∞:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
                md_content.append(f"- **–¢–∏–ø –¥–∞–Ω–Ω—ã—Ö:** {type(data).__name__}")
                if isinstance(data, (list, dict)):
                    md_content.append(f"- **–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤:** {len(data)}")
                md_content.append("")
            
            # –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ
            if options.get('include_toc', False):
                md_content.append("## –û–≥–ª–∞–≤–ª–µ–Ω–∏–µ")
                md_content.append("- [–î–∞–Ω–Ω—ã–µ](#–¥–∞–Ω–Ω—ã–µ)")
                md_content.append("")
            
            # –û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            md_content.append("## –î–∞–Ω–Ω—ã–µ")
            md_content.append("")
            
            if isinstance(data, pd.DataFrame):
                # –¢–∞–±–ª–∏—Ü–∞ –≤ Markdown
                table_format = options.get('table_format', 'GitHub')
                if table_format == 'GitHub':
                    md_content.append(data.to_markdown(index=False))
                else:
                    # –ü—Ä–æ—Å—Ç–∞—è —Ç–∞–±–ª–∏—Ü–∞
                    md_content.append("| " + " | ".join(data.columns) + " |")
                    md_content.append("| " + " | ".join(["---"] * len(data.columns)) + " |")
                    for _, row in data.iterrows():
                        md_content.append("| " + " | ".join(str(cell) for cell in row) + " |")
            
            elif isinstance(data, list):
                for i, item in enumerate(data):
                    md_content.append(f"### –≠–ª–µ–º–µ–Ω—Ç {i+1}")
                    if isinstance(item, dict):
                        for key, value in item.items():
                            md_content.append(f"- **{key}:** {value}")
                    else:
                        md_content.append(f"{item}")
                    md_content.append("")
            
            elif isinstance(data, dict):
                for key, value in data.items():
                    md_content.append(f"### {key}")
                    if isinstance(value, (list, dict)):
                        md_content.append(f"```json\n{json.dumps(value, indent=2, ensure_ascii=False)}\n```")
                    else:
                        md_content.append(f"{value}")
                    md_content.append("")
            
            else:
                md_content.append(f"```\n{str(data)}\n```")
            
            return "\n".join(md_content)
            
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è Markdown: {str(e)}")
            return None
    
    def _create_tar_archive(self, data: Any, options: Dict[str, Any]) -> bytes:
        """–°–æ–∑–¥–∞–Ω–∏–µ TAR –∞—Ä—Ö–∏–≤–∞"""
        try:
            import tarfile
            
            buffer = BytesIO()
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä–µ–∂–∏–º —Å–∂–∞—Ç–∏—è
            compression = options.get('compression', '–ù–µ—Ç')
            if compression == 'Gzip':
                mode = 'w:gz'
            elif compression == 'Bzip2':
                mode = 'w:bz2'
            else:
                mode = 'w'
            
            with tarfile.open(fileobj=buffer, mode=mode) as tar:
                # –î–æ–±–∞–≤–ª—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
                if isinstance(data, list):
                    # –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º –≤ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ–æ—Ä–º–∞—Ç–æ–≤
                    formats_to_include = ['csv', 'json', 'txt']
                    
                    for fmt in formats_to_include:
                        try:
                            if fmt == 'csv':
                                df = pd.DataFrame(data)
                                csv_data = df.to_csv(index=False)
                                tarinfo = tarfile.TarInfo(name=f"data.{fmt}")
                                tarinfo.size = len(csv_data.encode('utf-8'))
                                tar.addfile(tarinfo, BytesIO(csv_data.encode('utf-8')))
                            elif fmt == 'json':
                                json_data = json.dumps(data, indent=2, ensure_ascii=False)
                                tarinfo = tarfile.TarInfo(name=f"data.{fmt}")
                                tarinfo.size = len(json_data.encode('utf-8'))
                                tar.addfile(tarinfo, BytesIO(json_data.encode('utf-8')))
                            elif fmt == 'txt':
                                txt_data = '\n'.join([str(item) for item in data])
                                tarinfo = tarfile.TarInfo(name=f"data.{fmt}")
                                tarinfo.size = len(txt_data.encode('utf-8'))
                                tar.addfile(tarinfo, BytesIO(txt_data.encode('utf-8')))
                        except:
                            continue
                
                # –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
                if options.get('include_metadata', True):
                    metadata = {
                        'export_time': datetime.now().isoformat(),
                        'data_type': type(data).__name__,
                        'data_size': len(data) if isinstance(data, (list, dict)) else 1,
                        'export_options': options
                    }
                    
                    metadata_json = json.dumps(metadata, indent=2, ensure_ascii=False)
                    tarinfo = tarfile.TarInfo(name="metadata.json")
                    tarinfo.size = len(metadata_json.encode('utf-8'))
                    tar.addfile(tarinfo, BytesIO(metadata_json.encode('utf-8')))
            
            return buffer.getvalue()
            
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è TAR –∞—Ä—Ö–∏–≤–∞: {str(e)}")
            return None
    
    def _create_sql_export(self, data: Any, options: Dict[str, Any]) -> str:
        """–°–æ–∑–¥–∞–Ω–∏–µ SQL —ç–∫—Å–ø–æ—Ä—Ç–∞"""
        try:
            sql_content = []
            
            table_name = options.get('table_name', 'exported_data')
            include_drop = options.get('include_drop', False)
            include_create = options.get('include_create', True)
            batch_size = options.get('batch_size', 100)
            
            # DROP TABLE
            if include_drop:
                sql_content.append(f"DROP TABLE IF EXISTS `{table_name}`;")
                sql_content.append("")
            
            if isinstance(data, pd.DataFrame):
                # CREATE TABLE
                if include_create:
                    sql_content.append(f"CREATE TABLE `{table_name}` (")
                    
                    columns = []
                    for col in data.columns:
                        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å—Ç–æ–ª–±—Ü–∞
                        dtype = str(data[col].dtype)
                        if 'int' in dtype:
                            sql_type = 'INT'
                        elif 'float' in dtype:
                            sql_type = 'FLOAT'
                        elif 'bool' in dtype:
                            sql_type = 'BOOLEAN'
                        else:
                            sql_type = 'TEXT'
                        
                        columns.append(f"  `{col}` {sql_type}")
                    
                    sql_content.append(",\n".join(columns))
                    sql_content.append(");")
                    sql_content.append("")
                
                # INSERT statements
                for i in range(0, len(data), batch_size):
                    batch = data.iloc[i:i+batch_size]
                    
                    sql_content.append(f"INSERT INTO `{table_name}` VALUES")
                    
                    values = []
                    for _, row in batch.iterrows():
                        row_values = []
                        for value in row:
                            if pd.isna(value):
                                row_values.append('NULL')
                            elif isinstance(value, str):
                                # –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º –∫–∞–≤—ã—á–∫–∏
                                escaped_value = value.replace("'", "''")
                                row_values.append(f"'{escaped_value}'")
                            else:
                                row_values.append(str(value))
                        
                        values.append(f"({', '.join(row_values)})")
                    
                    sql_content.append(",\n".join(values) + ";")
                    sql_content.append("")
            
            elif isinstance(data, list):
                # –ü—Ä–æ—Å—Ç–æ–π —ç–∫—Å–ø–æ—Ä—Ç —Å–ø–∏—Å–∫–∞
                sql_content.append(f"CREATE TABLE `{table_name}` (")
                sql_content.append("  `id` INT AUTO_INCREMENT PRIMARY KEY,")
                sql_content.append("  `value` TEXT")
                sql_content.append(");")
                sql_content.append("")
                
                for i, item in enumerate(data):
                    escaped_value = str(item).replace("'", "''")
                    sql_content.append(f"INSERT INTO `{table_name}` (`value`) VALUES ('{escaped_value}');")
            
            return "\n".join(sql_content)
            
        except Exception as e:
            st.error(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è SQL: {str(e)}")
            return None
